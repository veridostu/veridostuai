require('dotenv').config();
const express = require('express');
const path = require('path');
const axios = require('axios');
const supabase = require('./utils/supabase');
const binanceService = require('./services/binance');
const cmcService = require('./services/coinmarketcap');
const openaiService = require('./services/openai');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json({ limit: '10mb' })); // G√∂rsel i√ßin limit artƒ±rƒ±ldƒ±
app.use(express.urlencoded({ limit: '10mb', extended: true }));
app.use(express.static('public'));

// Root
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

/**
 * Kullanƒ±cƒ± kontrol√º middleware
 */
async function checkUser(req, res, next) {
  const telegramId = req.query.telegram_id || req.body.telegram_id;

  if (!telegramId) {
    return res.status(400).json({ error: 'Telegram ID gerekli' });
  }

  const { data: user, error } = await supabase
    .from('users')
    .select('*')
    .eq('telegram_id', telegramId)
    .single();

  if (error || !user || !user.is_active) {
    return res.status(403).json({ error: 'Yetkisiz eri≈üim' });
  }

  // Abonelik kontrol√º
  const now = new Date();
  const subscriptionEnd = new Date(user.subscription_end);

  if (subscriptionEnd < now) {
    return res.status(403).json({ error: 'Aboneliƒüinizin s√ºresi dolmu≈ü' });
  }

  req.user = user;
  next();
}

// API Endpoints

/**
 * Kayƒ±t ƒ∞≈ülemi
 */
app.post('/api/register', async (req, res) => {
  try {
    const { telegram_id, username, first_name, last_name, payment_screenshot } = req.body;

    if (!telegram_id || !payment_screenshot) {
      return res.status(400).json({ error: 'Telegram ID ve √∂deme g√∂rseli gerekli' });
    }

    // Daha √∂nce kayƒ±t var mƒ± kontrol et
    const { data: existingRequest } = await supabase
      .from('payment_requests')
      .select('*')
      .eq('telegram_id', telegram_id)
      .eq('status', 'pending')
      .single();

    if (existingRequest) {
      return res.json({
        success: true,
        requestId: existingRequest.id,
        message: 'Zaten bekleyen bir talebiniz var'
      });
    }

    // Yeni kayƒ±t talebi olu≈ütur
    const { data, error } = await supabase
      .from('payment_requests')
      .insert([{
        telegram_id,
        username: username || '',
        first_name: first_name || '',
        last_name: last_name || '',
        payment_screenshot_url: payment_screenshot,
        status: 'pending'
      }])
      .select()
      .single();

    if (error) {
      console.error('Kayƒ±t hatasƒ±:', error);
      return res.status(500).json({ error: 'Kayƒ±t olu≈üturulamadƒ±: ' + error.message });
    }

    // Admin'e bildirim g√∂nder
    try {
      const adminMessage = `üÜï Yeni Kayƒ±t Talebi!

üë§ Kullanƒ±cƒ±: ${first_name} ${last_name || ''}
üìù Username: @${username || 'Yok'}
üÜî Telegram ID: ${telegram_id}
üÜî Talep ID: ${data.id}
üì∏ √ñdeme Belgesi: Eklendi

Talebi onaylamak i√ßin: /onay ${data.id}`;

      // Telegram Bot API kullanarak mesaj g√∂nder
      const adminBotToken = process.env.ADMIN_BOT_TOKEN;
      const adminChatId = process.env.ADMIN_TELEGRAM_ID || telegram_id; // Yoksa kullanƒ±cƒ±nƒ±n kendisine g√∂nder (test i√ßin)

      await axios.post(`https://api.telegram.org/bot${adminBotToken}/sendMessage`, {
        chat_id: adminChatId,
        text: adminMessage,
        parse_mode: 'HTML'
      });

      console.log('Admin bildirimi g√∂nderildi:', data.id);
    } catch (notifyError) {
      console.error('Admin bildirimi g√∂nderilemedi:', notifyError.message);
      // Bildirim hatasƒ± kayƒ±t i≈ülemini etkilemesin
    }

    res.json({
      success: true,
      requestId: data.id,
      message: 'Kayƒ±t talebiniz alƒ±ndƒ±'
    });
  } catch (error) {
    console.error('Register API hatasƒ±:', error);
    res.status(500).json({ error: 'Bir hata olu≈ütu' });
  }
});

/**
 * Teknik Analiz
 */
app.post('/api/technical-analysis', checkUser, async (req, res) => {
  try {
    const { symbol, timeframe } = req.body;

    if (!symbol || !timeframe) {
      return res.status(400).json({ error: 'Symbol ve timeframe gerekli' });
    }

    // OpenAI kullanƒ±m kontrol√º
    const usageCheck = await openaiService.checkUsageLimit(req.user.telegram_id, supabase);

    if (!usageCheck.canUse) {
      return res.status(429).json({ error: 'G√ºnl√ºk kullanƒ±m limitiniz doldu', remaining: 0 });
    }

    // Binance'den veri √ßek
    const data = await binanceService.getCompleteAnalysis(symbol, timeframe);

    // OpenAI ile analiz yap
    const analysis = await openaiService.analyzeTechnical(data);

    // Kullanƒ±mƒ± artƒ±r
    await openaiService.incrementUsage(req.user.telegram_id, supabase);

    // Ge√ßmi≈üe kaydet
    await supabase.from('technical_analysis_history').insert([{
      telegram_id: req.user.telegram_id,
      symbol,
      timeframe,
      analysis_result: analysis
    }]);

    res.json({
      success: true,
      analysis,
      data,
      remaining: usageCheck.remaining - 1
    });
  } catch (error) {
    console.error('Technical Analysis API hatasƒ±:', error);
    res.status(500).json({ error: 'Analiz yapƒ±lamadƒ±' });
  }
});

/**
 * Coin AI Asistanƒ±
 */
app.post('/api/coin-ai', checkUser, async (req, res) => {
  try {
    const { query } = req.body;

    if (!query) {
      return res.status(400).json({ error: 'Query gerekli' });
    }

    // OpenAI kullanƒ±m kontrol√º
    const usageCheck = await openaiService.checkUsageLimit(req.user.telegram_id, supabase);

    if (!usageCheck.canUse) {
      return res.status(429).json({ error: 'G√ºnl√ºk kullanƒ±m limitiniz doldu', remaining: 0 });
    }

    // Kullanƒ±cƒ±nƒ±n sorusundan coin sembol√ºn√º veya ismini √ßƒ±kar ve CoinMarketCap'ten veri √ßek
    let coinData = {};

    try {
      // Query'den coin sembol√ºn√º √ßƒ±karmaya √ßalƒ±≈ü
      const queryUpper = query.toUpperCase();
      const words = queryUpper.split(' ');

      // Olasƒ± coin sembollerini bul (2-10 karakter arasƒ± kelimeler)
      const potentialSymbols = words.filter(word =>
        word.length >= 2 && word.length <= 10 && /^[A-Z0-9]+$/.test(word)
      );

      let matchedCoin = null;

      // √ñnce symbol ile direkt arama yap (en hƒ±zlƒ± y√∂ntem)
      if (potentialSymbols.length > 0) {
        for (const symbol of potentialSymbols) {
          try {
            const coinInfo = await cmcService.getCryptocurrencyQuotesLatest({
              symbol: symbol
            });

            if (coinInfo && Object.keys(coinInfo).length > 0) {
              const coinId = Object.keys(coinInfo)[0];
              matchedCoin = coinInfo[coinId];
              break;
            }
          } catch (e) {
            // Bu sembol bulunamadƒ±, devam et
            continue;
          }
        }
      }

      // Symbol ile bulunamadƒ±ysa, isim ile arama yap (coin map kullan)
      if (!matchedCoin) {
        try {
          // ƒ∞lk 5000 coin'in map'ini al (isim ve sembol i√ßerir)
          const coinMap = await cmcService.getCryptocurrencyMap({ limit: 5000 });

          // Query'de ge√ßen coin ismini veya sembol√ºn√º bul
          const foundCoin = coinMap.find(coin =>
            queryUpper.includes(coin.symbol.toUpperCase()) ||
            queryUpper.includes(coin.name.toUpperCase())
          );

          if (foundCoin) {
            const coinInfo = await cmcService.getCryptocurrencyQuotesLatest({
              id: foundCoin.id
            });
            matchedCoin = coinInfo[foundCoin.id];
          }
        } catch (e) {
          console.error('Coin map hatasƒ±:', e);
        }
      }

      if (matchedCoin) {
        // Belirli coin bulundu
        coinData = {
          coin: matchedCoin,
          globalMetrics: await cmcService.getGlobalMetricsQuotesLatest()
        };
      } else {
        // Coin bulunamadƒ± - genel piyasa verisi g√∂nder
        const listings = await cmcService.getCryptocurrencyListingsLatest({ limit: 10 });
        coinData = {
          globalMetrics: await cmcService.getGlobalMetricsQuotesLatest(),
          topCoins: listings
        };
      }
    } catch (err) {
      console.error('CMC veri √ßekme hatasƒ±:', err);
      coinData = { error: 'Veri √ßekilemedi' };
    }

    // OpenAI ile yanƒ±t olu≈ütur
    const response = await openaiService.analyzeCoin(query, coinData);

    // Kullanƒ±mƒ± artƒ±r
    await openaiService.incrementUsage(req.user.telegram_id, supabase);

    // Ge√ßmi≈üe kaydet
    await supabase.from('coin_ai_history').insert([{
      telegram_id: req.user.telegram_id,
      user_query: query,
      ai_response: response
    }]);

    res.json({
      success: true,
      response,
      remaining: usageCheck.remaining - 1
    });
  } catch (error) {
    console.error('Coin AI API hatasƒ±:', error);
    res.status(500).json({ error: 'Yanƒ±t olu≈üturulamadƒ±' });
  }
});

/**
 * Grafik Analizi (g√∂rsel ile)
 */
app.post('/api/chart-analysis', checkUser, async (req, res) => {
  try {
    const { imageUrl } = req.body;

    if (!imageUrl) {
      return res.status(400).json({ error: 'Image URL gerekli' });
    }

    // OpenAI kullanƒ±m kontrol√º
    const usageCheck = await openaiService.checkUsageLimit(req.user.telegram_id, supabase);

    if (!usageCheck.canUse) {
      return res.status(429).json({ error: 'G√ºnl√ºk kullanƒ±m limitiniz doldu', remaining: 0 });
    }

    // OpenAI ile g√∂rsel analizi
    const analysis = await openaiService.analyzeChart(imageUrl);

    // Kullanƒ±mƒ± artƒ±r
    await openaiService.incrementUsage(req.user.telegram_id, supabase);

    res.json({
      success: true,
      analysis,
      remaining: usageCheck.remaining - 1
    });
  } catch (error) {
    console.error('Chart Analysis API hatasƒ±:', error);
    res.status(500).json({ error: 'Grafik analiz edilemedi' });
  }
});

/**
 * Trading Sinyalleri
 */
app.get('/api/trading-signals', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('trading_signals')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(50);

    if (error) throw error;

    res.json({ success: true, signals: data });
  } catch (error) {
    console.error('Trading Signals API hatasƒ±:', error);
    res.status(500).json({ error: 'Sinyaller getirilemedi' });
  }
});

/**
 * Market Screener
 */
app.get('/api/market-screener/:category', checkUser, async (req, res) => {
  try {
    const { category } = req.params;

    const { data, error } = await supabase
      .from('market_screener')
      .select('*')
      .eq('category', category)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (error) throw error;

    res.json({ success: true, data: data.data });
  } catch (error) {
    console.error('Market Screener API hatasƒ±:', error);
    res.status(500).json({ error: 'Veriler getirilemedi' });
  }
});

/**
 * Ekonomik G√∂stergeler
 */
app.get('/api/economic-indicators', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('economic_indicators')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) throw error;

    res.json({ success: true, indicators: data });
  } catch (error) {
    console.error('Economic Indicators API hatasƒ±:', error);
    res.status(500).json({ error: 'G√∂stergeler getirilemedi' });
  }
});

/**
 * Fear & Greed Index
 */
app.get('/api/fear-greed', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('fear_greed_index')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (error) throw error;

    res.json({ success: true, data });
  } catch (error) {
    console.error('Fear & Greed API hatasƒ±:', error);
    res.status(500).json({ error: 'Index getirilemedi' });
  }
});

/**
 * Whale Alerts
 */
app.get('/api/whale-alerts', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('whale_alerts')
      .select('*')
      .order('timestamp', { ascending: false })
      .limit(50);

    if (error) throw error;

    res.json({ success: true, alerts: data });
  } catch (error) {
    console.error('Whale Alerts API hatasƒ±:', error);
    res.status(500).json({ error: 'Whale alerts getirilemedi' });
  }
});

/**
 * Haberler
 */
app.get('/api/news', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('news')
      .select('*')
      .order('pub_date', { ascending: false })
      .limit(30);

    if (error) throw error;

    res.json({ success: true, news: data });
  } catch (error) {
    console.error('News API hatasƒ±:', error);
    res.status(500).json({ error: 'Haberler getirilemedi' });
  }
});

/**
 * Ge√ßmi≈ü Analizler - Teknik
 */
app.get('/api/history/technical', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('technical_analysis_history')
      .select('*')
      .eq('telegram_id', req.user.telegram_id)
      .order('created_at', { ascending: false })
      .limit(20);

    if (error) throw error;

    res.json({ success: true, history: data });
  } catch (error) {
    console.error('Technical History API hatasƒ±:', error);
    res.status(500).json({ error: 'Ge√ßmi≈ü getirilemedi' });
  }
});

/**
 * Ge√ßmi≈ü Analizler - AI Chat
 */
app.get('/api/history/ai-chat', checkUser, async (req, res) => {
  try {
    const { data, error } = await supabase
      .from('coin_ai_history')
      .select('*')
      .eq('telegram_id', req.user.telegram_id)
      .order('created_at', { ascending: false })
      .limit(20);

    if (error) throw error;

    res.json({ success: true, history: data });
  } catch (error) {
    console.error('AI Chat History API hatasƒ±:', error);
    res.status(500).json({ error: 'Ge√ßmi≈ü getirilemedi' });
  }
});

/**
 * Kullanƒ±cƒ± Bilgileri
 */
app.get('/api/user-info', checkUser, async (req, res) => {
  try {
    const usageCheck = await openaiService.checkUsageLimit(req.user.telegram_id, supabase);

    res.json({
      success: true,
      user: {
        name: `${req.user.first_name} ${req.user.last_name || ''}`,
        username: req.user.username,
        subscription_start: req.user.subscription_start,
        subscription_end: req.user.subscription_end,
        daily_usage: usageCheck.used,
        daily_limit: parseInt(process.env.DAILY_OPENAI_LIMIT || 100),
        remaining: usageCheck.remaining
      }
    });
  } catch (error) {
    console.error('User Info API hatasƒ±:', error);
    res.status(500).json({ error: 'Kullanƒ±cƒ± bilgileri getirilemedi' });
  }
});

// Server ba≈ülat
app.listen(PORT, () => {
  console.log(`üöÄ Server ${PORT} portunda √ßalƒ±≈üƒ±yor`);
  console.log(`üì± Web App URL: http://localhost:${PORT}`);
});
